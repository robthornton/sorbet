test.rb:21: Expected `A` but found `Box::Elem` for argument `a` https://srb.help/7002
    21 |    takes_a(x)
                    ^
  Expected `A` for argument `a` of method `Object#takes_a`:
    test.rb:9:
     9 |sig {params(a: A).void}
                    ^
  Got `Box::Elem` originating from:
    test.rb:19:
    19 |  def initialize(x)
                         ^

test.rb:59: Revealed type: `T.untyped` https://srb.help/7014
    59 |    T.reveal_type(props)
            ^^^^^^^^^^^^^^^^^^^^
  Got `T.untyped` originating from:
    test.rb:58:
    58 |    props = model.class.all_props
                    ^^^^^^^^^^^^^^^^^^^^^
Errors: 2

--------------------------------------------------------------------------

# typed: true
extend T::Sig

class A
  def only_on_a; end
end
class B; end

sig {params(a: A).void}
def takes_a(a); end

class Box
  extend T::Sig
  extend T::Generic

  Elem = type_member

  sig {params(x: Elem).void}
  def initialize(x)
    x.only_on_a
    takes_a(x)
  end
end

Box[A].new(A.new)
Box[B].new(B.new)

module HasProps
  extend T::Helpers
  def prop(name, type); end

  module ClassMethods
    extend T::Sig
    sig {returns(T::Array[Symbol])}
    def all_props; []; end
  end
  mixes_in_class_methods(ClassMethods)
end

class ChalkODMDocument
  include HasProps
end

class DataView
  extend T::Sig
  extend T::Generic
  DataViewModelBad = type_template
  DataViewModel = type_template {{upper: ChalkODMDocument}}

  sig {params(model: DataViewModelBad).returns(T.attached_class)}
  def self.bad_from_instance(model)
    model.class.props
    new()
  end

  sig {params(model: DataViewModel).returns(T.attached_class)}
  def self.from_instance(model)
    props = model.class.all_props
    T.reveal_type(props)

    model.does_not_exist
    new()
  end
end

--------------------------------------------------------------------------

test.rb:21: Expected `A` but found `Box::Elem` for argument `a` https://srb.help/7002
    21 |    takes_a(x)
                    ^
  Expected `A` for argument `a` of method `Object#takes_a`:
    test.rb:9:
     9 |sig {params(a: A).void}
                    ^
  Got `Box::Elem` originating from:
    test.rb:19:
    19 |  def initialize(x)
                         ^
  Autocorrect: Done
    test.rb:21: Replaced with `T.unsafe(x)`
    21 |    takes_a(x)
                    ^

test.rb:59: Revealed type: `T.untyped` https://srb.help/7014
    59 |    T.reveal_type(props)
            ^^^^^^^^^^^^^^^^^^^^
  Got `T.untyped` originating from:
    test.rb:58:
    58 |    props = model.class.all_props
                    ^^^^^^^^^^^^^^^^^^^^^
Errors: 2

--------------------------------------------------------------------------

# typed: true
extend T::Sig

class A
  def only_on_a; end
end
class B; end

sig {params(a: A).void}
def takes_a(a); end

class Box
  extend T::Sig
  extend T::Generic

  Elem = type_member

  sig {params(x: Elem).void}
  def initialize(x)
    x.only_on_a
    takes_a(T.unsafe(x))
  end
end

Box[A].new(A.new)
Box[B].new(B.new)

module HasProps
  extend T::Helpers
  def prop(name, type); end

  module ClassMethods
    extend T::Sig
    sig {returns(T::Array[Symbol])}
    def all_props; []; end
  end
  mixes_in_class_methods(ClassMethods)
end

class ChalkODMDocument
  include HasProps
end

class DataView
  extend T::Sig
  extend T::Generic
  DataViewModelBad = type_template
  DataViewModel = type_template {{upper: ChalkODMDocument}}

  sig {params(model: DataViewModelBad).returns(T.attached_class)}
  def self.bad_from_instance(model)
    model.class.props
    new()
  end

  sig {params(model: DataViewModel).returns(T.attached_class)}
  def self.from_instance(model)
    props = model.class.all_props
    T.reveal_type(props)

    model.does_not_exist
    new()
  end
end
